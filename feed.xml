<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://ayushkoul00.github.io/CP-Notes/</id><title>Ayush Koul</title><subtitle>A site containing my CP notes</subtitle> <updated>2022-07-25T13:22:25+05:30</updated> <author> <name>Ayush Koul</name> <uri>https://ayushkoul00.github.io/CP-Notes/</uri> </author><link rel="self" type="application/atom+xml" href="https://ayushkoul00.github.io/CP-Notes/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://ayushkoul00.github.io/CP-Notes/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Ayush Koul </rights> <icon>/CP-Notes/assets/img/favicons/favicon.ico</icon> <logo>/CP-Notes/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Vacation</title><link href="https://ayushkoul00.github.io/CP-Notes/posts/Vacation/" rel="alternate" type="text/html" title="Vacation" /><published>2022-07-25T00:00:00+05:30</published> <updated>2022-07-25T00:00:00+05:30</updated> <id>https://ayushkoul00.github.io/CP-Notes/posts/Vacation/</id> <content src="https://ayushkoul00.github.io/CP-Notes/posts/Vacation/" /> <author> <name>Ayush Koul</name> </author> <category term="Problems" /> <summary> Note: This problem is part of the Atcoder Educational Dp Contest Problem Link Brute-Force/Recursive Approach We know that we cannot take any given activity for two or more days in a row. So our decision to choose an activity will depend on what our previous decisions were: we will pass two parameters in our recursive function: i and j. Here, i denotes the ith day and j denotes the activi... </summary> </entry> <entry><title>Unbounded Knapsack</title><link href="https://ayushkoul00.github.io/CP-Notes/posts/Unbouned-Knapsack/" rel="alternate" type="text/html" title="Unbounded Knapsack" /><published>2022-07-21T00:00:00+05:30</published> <updated>2022-07-25T13:21:56+05:30</updated> <id>https://ayushkoul00.github.io/CP-Notes/posts/Unbouned-Knapsack/</id> <content src="https://ayushkoul00.github.io/CP-Notes/posts/Unbouned-Knapsack/" /> <author> <name>Ayush Koul</name> </author> <category term="Concepts" /> <category term="Dynamic Programming" /> <summary> Problem Statement: We are given an array of n items, each with a weight ($\boldsymbol{W_i}$) and a profit ($\boldsymbol{P_i}$),and a bag (aka knapsack) which has a limited capacity of $\boldsymbol{C}$ (where $\boldsymbol{C}$ is the maximum amount of weight that the bag can hold). The goal is to find a subset of the items such that their total weight is &amp;lt;= C and the sum of their profits is ma... </summary> </entry> <entry><title>Frog 2</title><link href="https://ayushkoul00.github.io/CP-Notes/posts/Frog2/" rel="alternate" type="text/html" title="Frog 2" /><published>2022-07-18T00:00:00+05:30</published> <updated>2022-07-18T00:00:00+05:30</updated> <id>https://ayushkoul00.github.io/CP-Notes/posts/Frog2/</id> <content src="https://ayushkoul00.github.io/CP-Notes/posts/Frog2/" /> <author> <name>Ayush Koul</name> </author> <category term="Problems" /> <summary> Note: This problem is part of the Atcoder Educational Dp Contest Problem Link Brute-Force/Recursive Approach Building from the logic of Frog 1, we know that if a frog can jump k stones ahead from a stone i, this also implies that a frog can only reach stone i by jumping from the previous k stones. Code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int recursive(vector&amp;lt;int&amp;gt; ... </summary> </entry> <entry><title>Frog 1</title><link href="https://ayushkoul00.github.io/CP-Notes/posts/Frog1/" rel="alternate" type="text/html" title="Frog 1" /><published>2022-07-18T00:00:00+05:30</published> <updated>2022-07-18T00:00:00+05:30</updated> <id>https://ayushkoul00.github.io/CP-Notes/posts/Frog1/</id> <content src="https://ayushkoul00.github.io/CP-Notes/posts/Frog1/" /> <author> <name>Ayush Koul</name> </author> <category term="Problems" /> <summary> Note: This problem is part of the Atcoder Educational Dp Contest Problem Link Brute-Force/Recursive Approach We know that from given h[i], we can only go to either h[i+1] or h[i+2]. If we reverse this logic, we can see that from any given h[i], we can only arrive there either from h[i-1] or h[i-2]. Finally, the cost of arriving at h[0] is 0 (since we are already there when we start) and... </summary> </entry> <entry><title>Kadane's Algorithm</title><link href="https://ayushkoul00.github.io/CP-Notes/posts/Kadane/" rel="alternate" type="text/html" title="Kadane's Algorithm" /><published>2022-07-07T00:00:00+05:30</published> <updated>2022-07-18T12:04:34+05:30</updated> <id>https://ayushkoul00.github.io/CP-Notes/posts/Kadane/</id> <content src="https://ayushkoul00.github.io/CP-Notes/posts/Kadane/" /> <author> <name>Ayush Koul</name> </author> <category term="Concepts" /> <category term="Special Algorithms" /> <summary> Problem Statement We are given an array of size n and we need to find the maximum subarray sum. Note: A subarray is a contiguous section of numbers from the original array Given: $A : [ A_0, A_1 … A_{n-1}] \ (Size = n)$ Brute-Force Approach The brute-force or naïve approach to this problem is to find the sum of all possible subarrays and then find the maximum among them. Lets supp... </summary> </entry> </feed>
