[ { "title": "Vacation", "url": "/CP-Notes/posts/Vacation/", "categories": "Problems", "tags": "dp problems", "date": "2022-07-25 00:00:00 +0530", "snippet": " Note: This problem is part of the Atcoder Educational Dp ContestProblem LinkBrute-Force/Recursive ApproachWe know that we cannot take any given activity for two or more days in a row. So our decision to choose an activity will depend on what our previous decisions were: we will pass two parameters in our recursive function: i and j. Here, i denotes the ith day and j denotes the activity choosen on the i+1th day (0-&gt;A, 1-&gt;B, 2-&gt;C). Our basic logic is: we will only consider activities on the ith day that doesn’t equal j because we already chose that on the next day. Therefore, the maximum points we can gain is by choosing one of the two remaining activities for the ith day plus the profit from the previous days (recursively).Code#include &lt;bits/stdc++.h&gt;using namespace std;int recursive(vector&lt;vector&lt;int&gt;&gt; &amp;act, int i, int j){ int res = 0; if (i &lt; 0) return res; if (i == 0) { for (int a = 0; a &lt;= 2; ++a) { if (a == j) continue; res = max(res, act[a][0]); } return res; } for (int a = 0; a &lt;= 2; ++a) { if (a == j) continue; res = max(res, act[a][i] + recursive(act, i - 1, a)); } return res;}int main(){ int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; act(3, vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; act[0][i] &gt;&gt; act[1][i] &gt;&gt; act[2][i]; cout &lt;&lt; max({recursive(act, n - 2, 0) + act[0][n - 1], recursive(act, n - 2, 1) + act[1][n - 1], recursive(act, n - 2, 2) + act[2][n - 1]});}Complexity Analysis Time complexity: $\\boldsymbol{O(2^n)}$ - Size of recursion tree will be $2^n$ Space complexity: $\\boldsymbol{O(n)}$ - The depth of the recursion tree can go up to $n$.Recursive (Top-down) + MemoizationHere, we cache the results of the recursive brute-force approach to reduce time complexity:Code#include &lt;bits/stdc++.h&gt;using namespace std;int n;int topdown(vector&lt;vector&lt;int&gt;&gt; &amp;act, int i, int j){ static vector&lt;vector&lt;int&gt;&gt; dp(3, vector&lt;int&gt;(n, -1)); if(dp[j][i] != -1) return dp[j][i]; int res = 0; if (i &lt; 0) return dp[j][i] = res; if (i == 0) { for (int a = 0; a &lt;= 2; ++a) { if (a == j) continue; res = max(res, act[a][0]); } return dp[j][i] = res; } for (int a = 0; a &lt;= 2; ++a) { if (a == j) continue; res = max(res, act[a][i] + topdown(act, i - 1, a)); } return dp[j][i] = res;}int main(){ cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; act(3, vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; act[0][i] &gt;&gt; act[1][i] &gt;&gt; act[2][i]; cout &lt;&lt; max({topdown(act, n - 2, 0) + act[0][n - 1], topdown(act, n - 2, 1) + act[1][n - 1], topdown(act, n - 2, 2) + act[2][n - 1]});}Complexity Analysis Time complexity: $\\boldsymbol{O(n)}$ - This is because the recursive function will only branch or call other recursive functions if it hasn’t cached the query yet. The number of possible calls is $n$ (We have to explore each stone) Space complexity: $\\boldsymbol{O(n)}$ - We are caching $n$ results in our DP array and size of recursive stack is also at worst $n$. Bottom-Up (Tabular)From the recurrence relation, we can come up with the bottom up approach:Base cases:if (i &lt; 0)\treturn dp[j][i] = 0;if (i == 0){\tfor (int a = 0; a &lt;= 2; ++a)\t{\t\tif (a == j) continue;\t\tdp[j][i] = max(dp[j][i], act[a][0]);\t}\treturn dp[j][i];}Recurrence Relation:for (int a = 0; a &lt;= 2; ++a){\tif (a == j) continue;\tdp[j][i] = max(dp[j][i], act[a][i] + topdown(act, i - 1, a));}return dp[j][i];Code#include &lt;bits/stdc++.h&gt;using namespace std;int n;int bottomup(vector&lt;vector&lt;int&gt;&gt; &amp;act){ vector&lt;vector&lt;int&gt;&gt; dp(3, vector&lt;int&gt;(n + 1)); for (int i = 1; i &lt;= n; ++i) { int a = act[0][i-1], b = act[1][i-1], c = act[2][i-1]; dp[0][i] = max(dp[1][i - 1] + b, dp[2][i - 1] + c); dp[1][i] = max(dp[0][i - 1] + a, dp[2][i - 1] + c); dp[2][i] = max(dp[0][i - 1] + a, dp[1][i - 1] + b); } return max({dp[0][n], dp[1][n], dp[2][n]});} int main(){ cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; act(3, vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; act[0][i] &gt;&gt; act[1][i] &gt;&gt; act[2][i]; cout &lt;&lt; bottomup(act); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n)}$ - We have single for loop that run in total of $n$ times. Space complexity: $\\boldsymbol{O(n)}$ - We are caching $n$ results in our DP array." }, { "title": "Unbounded Knapsack", "url": "/CP-Notes/posts/Unbouned-Knapsack/", "categories": "Concepts, Dynamic Programming", "tags": "knapsack", "date": "2022-07-21 00:00:00 +0530", "snippet": "Problem Statement:We are given an array of n items, each with a weight ($\\boldsymbol{W_i}$) and a profit ($\\boldsymbol{P_i}$),and a bag (aka knapsack) which has a limited capacity of $\\boldsymbol{C}$ (where $\\boldsymbol{C}$ is the maximum amount of weight that the bag can hold). The goal is to find a subset of the items such that their total weight is &lt;= C and the sum of their profits is maximum.Each item has an infinite quantity and can be used any amount of times.Given: $C$ $W : [W_0, W_1, … W_{n-1}] \\ (Size = n)$ $P : [P_0, P_1, … P_{n-1}] \\ (Size = n)$ Note: Each item can be used any number of times (unlike 0/1 Knapsack)Brute-Force/Recursive ApproachUnlike 0/1 Knapsack, we can use an item any number of times: $0, 1, … \\infty$. Therefore, here the approach is slightly different. Here, the main idea still remains the same: for each item, we have 2 choices: For each item, we can make 2 choices: to include it or to exclude it. However, the only difference is, if we include an item, we don’t move on. We have to also consider the possibility that it can be included again (Therefore, when we include an item, we dont decrement i):Code#include &lt;bits/stdc++.h&gt;using namespace std;/** * @param W array of item weights * @param P array of item profits * @param Space current capacity of the bag (before choosing item i) * @param i current item index (start from n-1)*/int knapsack(const vector&lt;int&gt; &amp;W, const vector&lt;int&gt; &amp;P, int Space, int i){ if (i == -1 || Space == 0) return 0; if (W[i] &gt; Space) return knapsack(W, P, Space, i - 1); //Exclude the item else return max(knapsack(W, P, Space, i - 1), //Exclude the item P[i] + knapsack(W, P, Space - W[i], i)); //Include the item}int main(){ vector&lt;int&gt; W = {7, 2, 4}, P = {10, 5, 6}; int C = 7; cout &lt;&lt; knapsack(W, P, C, W.size() - 1); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(2^n)}$ - Size of recursion tree will be $\\boldsymbol{2^n}$ Space complexity: $\\boldsymbol{O(n)}$ - The depth of the recursion tree can go up to $\\boldsymbol{n}$.Recursive (Top-down) + MemoizationHere, we will just cache each result so it is not re-computedCode#include &lt;bits/stdc++.h&gt;using namespace std;// A hash function used to hash a pair of any kindstruct hash_pair { template &lt;class T1, class T2&gt; size_t operator()(const pair&lt;T1, T2&gt;&amp; p) const { auto hash1 = hash&lt;T1&gt;{}(p.first); auto hash2 = hash&lt;T2&gt;{}(p.second); return hash1 ^ hash2; }};unordered_map&lt;pair&lt;int, int&gt;, int, hash_pair&gt; dp;/** * @param W array of item weights * @param P array of item profits * @param Space current capacity of the bag (before choosing item i) * @param i current item index (start from n-1)*/int knapsack(const vector&lt;int&gt; &amp;W, const vector&lt;int&gt; &amp;P, int Space, int i){ if(dp.find({i, Space}) != dp.end()) return dp[{i, Space}]; if (i == -1 || Space == 0) return dp[{i, Space}] = 0; if (W[i] &gt; Space) return dp[{i, Space}] = knapsack(W, P, Space, i - 1); //Exclude the item else return dp[{i, Space}] = max(knapsack(W, P, Space, i - 1), //Exclude the item P[i] + knapsack(W, P, Space - W[i], i)); //Include the item}int main(){ vector&lt;int&gt; W = {7, 2, 4}, P = {10, 5, 6}; int C = 7; cout &lt;&lt; knapsack(W, P, C, W.size() - 1); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n*C)}$ - This is because the recursive function will only branch or call other recursive functions if it hasn’t cached the query yet. The number of possible queries is $\\boldsymbol{n*C}$(For each item, we have to explore for all capacities &lt;= C) Space complexity: $\\boldsymbol{O(n + \\text{size of recursive call stack})}$ - We are caching $\\boldsymbol{n*C}$ results in our Hash Map.Bottom-Up (Tabular)In order to understand this approach, we need to refer back to the recurrence relation (how and when we call therecursive calls) we used in the Top-down method.//Base case:dp(i, 0) = 0dp(-1, Space) = 0//Recurrence Relationif (W[i] &gt; Space) dp(i, Space) = dp(i-1, Space)else dp(i, Space) = max(dp(i-1, Space), P[i] + dp(i, Space - W[i]))We know that i will be in the range of [0, n-1] and Space will be in the range of [1, C]. We can use this to change dp into a 2D matrix/array for caching the results. In addition, we will be generating the answer from the bottom up (i.e. calculating and storing the results of smaller sub problems then using those to calculate and store the larger ones). In top down, we start from the top (the answer we need, and recursively call the small sub problems), but here, we start from the bottom.One more point to note is that, our base case checks to see if i is -1 which we can’t use if we have an array (since they only go to index 0). Therefore, we will shift the values of i by +1 (make it 1 indexed) and reserve 0 for the -1 case (basically, in the code, dp[0][Space] = 0 since 0 works like -1)Code#include &lt;bits/stdc++.h&gt;using namespace std;/** * @param W array of item weights * @param P array of item profits * @param C capacity of the bag*/int knapsack(const vector&lt;int&gt; &amp;W, const vector&lt;int&gt; &amp;P, int C){ int n = W.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(C + 1)); //dp[0][Space] = 0 (by default in vector) //dp[i][0] = 0 (by default in vector) for (int i = 1; i &lt;= n; ++i) { for (int Space = 1; Space &lt;= C; ++Space) { if (W[i - 1] &gt; Space) dp[i][Space] = dp[i - 1][Space]; else dp[i][Space] = max(dp[i - 1][Space], P[i - 1] + dp[i][Space - W[i - 1]]); } } return dp[n][C];}int main(){ vector&lt;int&gt; W = {7, 2, 4}, P = {10, 5, 6}; int C = 7; cout &lt;&lt; knapsack(W, P, C, W.size() - 1); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n*C)}$ - We have 2 nested for loops that run in total of $\\boldsymbol{n*C}$ times. Space complexity: $\\boldsymbol{O(n*C)}$ - We are caching $\\boldsymbol{n*C}$ results in our 2D matrix/array." }, { "title": "Frog 2", "url": "/CP-Notes/posts/Frog2/", "categories": "Problems", "tags": "dp problems", "date": "2022-07-18 00:00:00 +0530", "snippet": " Note: This problem is part of the Atcoder Educational Dp ContestProblem LinkBrute-Force/Recursive ApproachBuilding from the logic of Frog 1, we know that if a frog can jump k stones ahead from a stone i, this also implies that a frog can only reach stone i by jumping from the previous k stones.Code#include &lt;bits/stdc++.h&gt;using namespace std;int recursive(vector&lt;int&gt; &amp;h, int k, int i){ if (i == 0) return 0; int res = INT_MAX; for (int j = max(0, i - k); j &lt; i; ++j) res = min(res, abs(h[i] - h[j]) + recursive(h, k, j)); return res;}int main(){ int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; h(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; h[i]; cout &lt;&lt; recursive(h, k, n-1); return 0;}n, k = input().split()n = int(n)k = int(k)h = list(map(int, input().strip().split()))def recursive(h, k, i): if i == 0: return 0 res = math.inf for j in range (max(0, i - k), i): res = min(res, abs(h[i] - h[j]) + recursive(h, k, j)) return res print(recursive(h, k, n-1))Complexity Analysis Time complexity: $\\boldsymbol{O(n^k)}$ - Size of recursion tree will be $n^k$ Space complexity: $\\boldsymbol{O(n)}$ - The depth of the recursion tree can go up to $n$.Recursive (Top-down) + MemoizationHere, we cache the results of the recursive brute-force approach to reduce time complexity:Code#include &lt;bits/stdc++.h&gt;using namespace std;int topdown(vector&lt;int&gt; &amp;h, int k, int i){ static vector&lt;int&gt; dp(h.size(), -1); if (dp[i] != -1) return dp[i]; if (i == 0) return dp[i] = 0; int res = INT_MAX; for (int j = max(0, i - k); j &lt; i; ++j) res = min(res, abs(h[i] - h[j]) + topdown(h, k, j)); return dp[i] = res;}int main(){ int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; h(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; h[i]; cout &lt;&lt; topdown(h, k, n-1); return 0;}n, k = input().split()n = int(n)k = int(k)h = list(map(int, input().strip().split()))dp = [-1 for x in range(0, n)]def topdown(h, k, i): if dp[i] != -1: return dp[i] if i == 0: dp[i] = 0 return dp[i] res = math.inf for j in range(max(0, i-k), i): res = min(res, abs(h[i]-h[j]) + topdown(h, k, j)) dp[i] = res return dp[i]print(topdown(h, k, n-1))Complexity Analysis Time complexity: $\\boldsymbol{O(n)}$ - This is because the recursive function will only branch or call other recursive functions if it hasn’t cached the query yet. The number of possible calls is $n$ (We have to explore each stone) Space complexity: $\\boldsymbol{O(n)}$ - We are caching $n$ results in our DP array and size of recursive stack is also at worst $n$. Bottom-Up (Tabular)From the recurrence relation, we can come up with the bottom up approach:Base Case:if (i == 0)\treturn dp[i] = 0;\tRecurrence Relation:\tdp[i] = max(dp[i], abs(h[i] - h[j]) + dp[j]) -&gt; for all j in range [i-k, i)Code#include &lt;bits/stdc++.h&gt;using namespace std;int bottomup(vector&lt;int&gt; &amp;h, int k){ int n = h.size(); vector&lt;int&gt; dp(n, INT_MAX); dp[0] = 0; for (int i = 1; i &lt; n; ++i) { for(int j = max(0, i - k); j &lt; i; ++j) dp[i] = min(dp[i], abs(h[i] - h[j]) + dp[j]); } return dp[n - 1];} int main(){ int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; h(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; h[i]; cout &lt;&lt; bottomup(h, k); return 0;}n, k = input().split()n = int(n)k = int(k)h = list(map(int, input().strip().split()))def bottomup(h, k): n = len(h) dp = [math.inf for x in range(0, n)] dp[0] = 0 for i in range(1, n): for j in range(max(0, i - k), i): dp[i] = min(dp[i], abs(h[i] - h[j]) + dp[j]) return dp[n -1]print(bottomup(h, k))Complexity Analysis Time complexity: $\\boldsymbol{O(n)}$ - We have single for loop that run in total of $n$ times. Space complexity: $\\boldsymbol{O(n)}$ - We are caching $n$ results in our DP array." }, { "title": "Frog 1", "url": "/CP-Notes/posts/Frog1/", "categories": "Problems", "tags": "dp problems", "date": "2022-07-18 00:00:00 +0530", "snippet": " Note: This problem is part of the Atcoder Educational Dp ContestProblem LinkBrute-Force/Recursive ApproachWe know that from given h[i], we can only go to either h[i+1] or h[i+2]. If we reverse this logic, we can see that from any given h[i], we can only arrive there either from h[i-1] or h[i-2]. Finally, the cost of arriving at h[0] is 0 (since we are already there when we start) and the cost for h[1] is |h[1] - h[0]| since we can only come to h[1] from h[0]Code#include &lt;bits/stdc++.h&gt;using namespace std;int recursive(vector&lt;int&gt; &amp;h, int i){ if (i == 0) return 0; if (i == 1) return abs(h[1] - h[0]); return min(abs(h[i] - h[i - 1]) + recursive(h, i - 1), abs(h[i] - h[i - 2]) + recursive(h, i - 2));}int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; h(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; h[i]; cout &lt;&lt; recursive(h, n-1); return 0;}n = int(input())nums = list(map(int, input().strip().split()))def recursive(nums): n = len(nums) def helper(index): if index == 0: return 0 if index == 1: return abs(nums[1] - nums[0])\t return min(abs(nums[index] - nums[index - 1]) + helper(index - 1), abs(nums[index] - nums[index - 2]) + helper(index - 2)) return helper(n - 1)print(recursive(nums))Complexity Analysis Time complexity: $\\boldsymbol{O(2^n)}$ - Size of recursion tree will be $2^n$ Space complexity: $\\boldsymbol{O(n)}$ - The depth of the recursion tree can go up to $n$.Recursive (Top-down) + MemoizationHere, we cache the results of the recursive brute-force approach to reduce time complexity:Code#include &lt;bits/stdc++.h&gt;using namespace std;int topdown(vector&lt;int&gt; &amp;h, int i){ static vector&lt;int&gt; dp(h.size(), -1); if (dp[i] != -1) return dp[i]; if (i == 0) return dp[i] = 0; if (i == 1) return dp[i] = abs(h[1] - h[0]); return dp[i] = min(abs(h[i] - h[i - 1]) + topdown(h, i - 1), abs(h[i] - h[i - 2]) + topdown(h, i - 2));}int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; h(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; h[i]; cout &lt;&lt; topdown(h, n-1); return 0;}n = int(input())nums = list(map(int, input().strip().split()))def topDown(nums): n = len(nums) dp = [-1] * n dp[0] = 0 dp[1] = abs(nums[1] - nums[0]) def helper(index): if index &lt; 0: return math.inf if dp[index] != -1: return dp[index] dp[index] = min(abs(nums[index - 1] - nums[index]) + helper(index - 1), abs(nums[index - 2] - nums[index]) + helper(index - 2)) return dp[index] return helper(n - 1)print(topDown(nums))Complexity Analysis Time complexity: $\\boldsymbol{O(n)}$ - This is because the recursive function will only branch or call other recursive functions if it hasn’t cached the query yet. The number of possible calls is $n$ (We have to explore each stone) Space complexity: $\\boldsymbol{O(n)}$ - We are caching $n$ results in our DP array and size of recursive stack is also at worst $n$. Bottom-Up (Tabular)From the recurrence relation, we can come up with the bottom up approach:Base cases:if (i == 0)\treturn dp[i] = 0;if (i == 1)\treturn dp[i] = abs(h[1] - h[0]);Recurrence Relation:dp[i] = min(abs(h[i] - h[i - 2]) + dp[i - 2], abs(h[i] - h[i - 1]) + dp[i - 1]);Code#include &lt;bits/stdc++.h&gt;using namespace std;int bottomup(vector&lt;int&gt; &amp;h){ int n = h.size(); vector&lt;int&gt; dp(n); dp[0] = 0, dp[1] = abs(h[1] - h[0]); for (int i = 2; i &lt; n; ++i) dp[i] = min(abs(h[i] - h[i - 2]) + dp[i - 2], abs(h[i] - h[i - 1]) + dp[i - 1]); return dp[n - 1];} int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; h(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; h[i]; cout &lt;&lt; bottomup(h); return 0;}n = int(input())nums = list(map(int, input().strip().split()))def bottomUp(nums, n): dp = [0] * n dp[0] = 0 dp[1] = abs(nums[0] - nums[1]) for i in range(2, n): dp[i] = min(abs(nums[i] - nums[i - 1]) + dp[i - 1], abs(nums[i] - nums[i - 2]) + dp[i - 2]) return dp[n-1] print(bottomUp(nums, n))Complexity Analysis Time complexity: $\\boldsymbol{O(n)}$ - We have single for loop that run in total of $n$ times. Space complexity: $\\boldsymbol{O(n)}$ - We are caching $n$ results in our DP array." }, { "title": "Kadane's Algorithm", "url": "/CP-Notes/posts/Kadane/", "categories": "Concepts, Special Algorithms", "tags": "kadane", "date": "2022-07-07 00:00:00 +0530", "snippet": "Problem StatementWe are given an array of size n and we need to find the maximum subarray sum. Note: A subarray is a contiguous section of numbers from the original arrayGiven: $A : [ A_0, A_1 … A_{n-1}] \\ (Size = n)$Brute-Force ApproachThe brute-force or naïve approach to this problem is to find the sum of all possible subarrays and then find the maximum among them.Lets suppose our array is [-1, 2, 4, -3, 5, 2, -5, 2]. The maximum sum of all possible subarrays would be 10. This is from the subarray: [-1, 2, 4, -3, 5, 2, -5, 2]Code#include &lt;bits/stdc++.h&gt;using namespace std;/** * @param A array of elements*/int bruteForce(const vector&lt;int&gt;&amp; A){ int n = a.size(); int maxSum = INT_MIN; for(int i = 0; i &lt; n; ++i) { for(int j = i; j &lt; n; ++j) { //Current Subarray is: A[i..j] int currSum = 0; for(int k = i; k &lt;= j; ++k) currSum += a[k]; maxSum = max(maxSum, currSum); } } return maxSum;}int main(){ vector&lt;int&gt; A = {-1, 2, 4, -3, 5, 2, -5, 2}; cout &lt;&lt; bruteForce(A); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n^3)}$ - We are generating all possible subarrays with starting index i and ending index j (A[i..j]) which takes $O(n^2)$ and for each subarray, we are summing all the numbers up which takes $O(n)$ (Hence $ n^2 * n = n^3 $) Space complexity: $\\boldsymbol{O(1)}$ - We are using no extra space other than the input array. Note: A[i..j] denotes the subarray starting at index i and ending at index jOptimized Brute-Force ApproachThe brute force approach find the sum of each A[i..j] subarray from the start. However, if we already know the sum for subarray A[i..j-1] we can just find the sum for subarray A[i..j] by adding A[j] to the sum of A[i..j-1]:Code#include &lt;bits/stdc++.h&gt;using namespace std;/** * @param A array of elements*/int optimizedBruteForce(const vector&lt;int&gt;&amp; A){ int n = a.size(); int maxSum = INT_MIN; for (int i = 0; i &lt; n; ++i) { int currSum = 0; for (int j = i; j &lt; n; ++j) { //Current Subarray is: A[i..j] currSum += a[j]; maxSum = max(maxSum, currSum); } } return maxSum;}int main(){ vector&lt;int&gt; A = {-1, 2, 4, -3, 5, 2, -5, 2}; cout &lt;&lt; bruteForce(A); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n^2)}$ - This is because we don’t re-calculate the sum of every subarray. Space complexity: $\\boldsymbol{O(1)}$ - We are using no extra space other than the input array.Kadane’s AlgorithmThere is an algorithm called kadane’s algorithm which solves this problem in O(n) - Linear time and O(1) - Constant space.Proof/Working of Kadane’s Algorithm (by Induction)Let: $Sum(i, j)$ denote the sum of the element in the subarry: A[i..j] $MaxSum(i)$ denote the maximum sum of all subarrays ending at index iOur goal is to find the maximum sum of all subarrays which is:\\[\\max_{\\forall \\ i \\ \\epsilon \\ \\{0,1...n-1\\}}MaxSum(i) = \\max(MaxSum(0), MaxSum(1) ... MaxSum(n-1))\\]We know:\\[Sum(i, j) = Sum(i, j-1) + A[j]\\]Using Induction, we can say:\\[MaxSum(i+1) = \\max(Sum(0, i) + A[i+1] ... Sum(i, i) + A[i+1], A[i+1])\\]\\[=\\max(Sum(0, i), Sum(1, i) ... Sum(i, i), 0) + A[i+1]\\]\\[=\\max(\\max(Sum(0, i), Sum(1, i) ... Sum(i, i)), 0) + A[i+1]\\]\\[=\\max(MaxSum(i), 0) + A[i+1]\\]\\[=\\max(MaxSum(i) + A[i+1], A[i+1])\\]\\[\\therefore MaxSum(i+1)=\\max(MaxSum(i) + A[i+1], A[i+1])\\]And the maximum sum of all subarrays will be:\\[\\max(MaxSum(0), MaxSum(1) ... MaxSum(n-1))\\]Code#include &lt;bits/stdc++.h&gt;using namespace std;/** * @param A array of elements*/int kadane(const vector&lt;int&gt;&amp; A){ int n = a.size(); int sum = 0, best = INT_MIN; for (int i = 0; i &lt; n; ++i) { // MaxSum(i) = max(MaxSum(i-1) + a[i], a[i]) sum = max(sum + a[i], a[i]); //max(MaxSum(0), MaxSum(1), ... , MaxSum(i)) best = max(best, sum); } return best;}int main(){ vector&lt;int&gt; A = {-1, 2, 4, -3, 5, 2, -5, 2}; cout &lt;&lt; bruteForce(A); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n)}$ - We are going through the array once Space complexity: $\\boldsymbol{O(1)}$ - We are using no extra space other than the input array." }, { "title": "0/1 Knapsack", "url": "/CP-Notes/posts/01-Knapsack/", "categories": "Concepts, Dynamic Programming", "tags": "knapsack", "date": "2022-06-29 00:00:00 +0530", "snippet": "Problem Statement:We are given an array of n items, each with a weight ($\\boldsymbol{W_i}$) and a profit ($\\boldsymbol{P_i}$), and a bag (aka knapsack) which has a limited capacity of $\\boldsymbol{C}$ (where $\\boldsymbol{C}$ is the maximum amount of weight that the bag can hold). The goal is to find a subset of the items such that their total weight is &lt;= C and the sum of their profits is maximum.Given: $C$ $W : [W_0, W_1, … W_{n-1}] \\ (Size = n)$ $P : [P_0, P_1, … P_{n-1}] \\ (Size = n)$ Note: Each item can only be used onceBrute-Force/Recursive ApproachFor each item, we can make 2 choices: to include it or to exclude it. Therefore, the number of combinationschoices we have is $\\boldsymbol{2^n}$. We can recursively choose or not choose an item, based on the space availablein the bag, and then keep track of the maximum profit attained throught all the subsets/combinations we go through.The recursive function knapsack will take the weight array (W), profit array (P), current space left in thebag (Space) and the current index of the item (i).For each item, it will first check to see if the weight of the item W[i] doesn’t excede the current capacity(Space) of the bag. If it does, the item will be excluded (since there is no other choice). Otherwise, we will find the maximum profit between including and excluding the item (because it is possible that the item is in the subset of items that result in the maximum profit and it is also possible that it is not in that subset - we need to consider both possibilites).0/1 Knapsack Recursive Decision Tree(Source)Code#include &lt;bits/stdc++.h&gt;using namespace std;/** * @param W array of item weights * @param P array of item profits * @param Space current capacity of the bag (before choosing item i) * @param i current item index (start from n-1)*/int knapsack(const vector&lt;int&gt; &amp;W, const vector&lt;int&gt; &amp;P, int Space, int i){ if (i == -1 || Space == 0) return 0; if (W[i] &gt; Space) return knapsack(W, P, Space, i - 1); //Exclude the item else return max(knapsack(W, P, Space, i - 1), //Exclude the item P[i] + knapsack(W, P, Space - W[i], i - 1)); //Include the item}int main(){ vector&lt;int&gt; W = {7, 2, 4}, P = {10, 5, 6}; int C = 7; cout &lt;&lt; knapsack(W, P, C, W.size() - 1); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(2^n)}$ - Size of recursion tree will be $\\boldsymbol{2^n}$ Space complexity: $\\boldsymbol{O(n)}$ - The depth of the recursion tree can go up to $\\boldsymbol{n}$.Recursive (Top-down) + MemoizationIf we notice, out recursive function only depends on two things: the items we choose (i) and the current capacity of the bag (Space). The weights and profit arrays remain constant in each call (we could choose to make them global as well). Therefore, if we think of the recursive call as knapsack(Space, i) then we can see that out recursive function re-calculates a call with the same parameters multiple times. Example:In the following recursion tree, K(a, b) refers to knapSack(Space, i).The recursion tree is for following sample inputs.W[] = {1, 1, 1}, P[] = {10, 20, 30}, C = 2 K(C, n-1) K(2, 3) / \\ / \\ K(2, 2) K(1, 2) / \\ / \\ / \\ / \\ K(2, 1) K(1, 1) K(1, 1) K(0, 1) / \\ / \\ / / \\ / \\ / K(2, 0) K(1, 0) K(1, 0) K(0, 0) K(1, 0) We can see that K(1, 1) is calculated multiple times. Eventhough it may seem like a small calculation from the example, it is actually very expensive. Imagine if the tree was very deep and we can to calculate the same sub-problems (aka sub-calls) multiple times, it would make the time complexity exponential (which is seen in the brute-force approach). Caching the result saves this time and only explores new sub-problems/sub-calls that haven’t been cached.Code#include &lt;bits/stdc++.h&gt;using namespace std;// A hash function used to hash a pair of any kindstruct hash_pair { template &lt;class T1, class T2&gt; size_t operator()(const pair&lt;T1, T2&gt;&amp; p) const { auto hash1 = hash&lt;T1&gt;{}(p.first); auto hash2 = hash&lt;T2&gt;{}(p.second); return hash1 ^ hash2; }};unordered_map&lt;pair&lt;int, int&gt;, int, hash_pair&gt; dp;/** * @param W array of item weights * @param P array of item profits * @param Space current capacity of the bag (before choosing item i) * @param i current item index (start from n-1)*/int knapsack(const vector&lt;int&gt; &amp;W, const vector&lt;int&gt; &amp;P, int Space, int i){ if(dp.find({i, Space}) != dp.end()) return dp[{i, Space}]; if (i == -1 || Space == 0) return dp[{i, Space}] = 0; if (W[i] &gt; Space) return dp[{i, Space}] = knapsack(W, P, Space, i - 1); //Exclude the item else return dp[{i, Space}] = max(knapsack(W, P, Space, i - 1), //Exclude the item P[i] + knapsack(W, P, Space - W[i], i - 1)); //Include the item}int main(){ vector&lt;int&gt; W = {7, 2, 4}, P = {10, 5, 6}; int C = 7; cout &lt;&lt; knapsack(W, P, C, W.size() - 1); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n*C)}$ - This is because the recursive function will only branch or call other recursive functions if it hasn’t cached the query yet. The number of possible queries is $\\boldsymbol{n*C}$(For each item, we have to explore for all capacities &lt;= C) Space complexity: $\\boldsymbol{O(n + \\text{size of recursive call stack})}$ - We are caching $\\boldsymbol{n*C}$ results in our Hash Map.Bottom-Up (Tabular)In order to understand this approach, we need to refer back to the recurrence relation (how and when we call therecursive calls) we used in the Top-down method.//Base case:dp(i, 0) = 0dp(-1, Space) = 0//Recurrence Relationif (W[i] &gt; Space) dp(i, Space) = dp(i-1, Space)else dp(i, Space) = max(dp(i-1, Space), P[i] + dp(i-1, Space - W[i]))We know that i will be in the range of [0, n-1] and Space will be in the range of [1, C]. We can use this to change dp into a 2D matrix/array for caching the results. In addition, we will be generating the answer from the bottom up (i.e. calculating and storing the results of smaller sub problems then using those to calculate and store the larger ones). In top down, we start from the top (the answer we need, and recursively call the small sub problems), but here, we start from the bottom.One more point to note is that, our base case checks to see if i is -1 which we can’t use if we have an array (since they only go to index 0). Therefore, we will shift the values of i by +1 (make it 1 indexed) and reserve 0 for the -1 case (basically, in the code, dp[0][Space] = 0 since 0 works like -1)Code#include &lt;bits/stdc++.h&gt;using namespace std;/** * @param W array of item weights * @param P array of item profits * @param C capacity of the bag*/int knapsack(const vector&lt;int&gt; &amp;W, const vector&lt;int&gt; &amp;P, int C){ int n = W.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(C + 1)); //dp[0][Space] = 0 (by default in vector) //dp[i][0] = 0 (by default in vector) for (int i = 1; i &lt;= n; ++i) { for (int Space = 1; Space &lt;= C; ++Space) { if (W[i - 1] &gt; Space) dp[i][Space] = dp[i - 1][Space]; else dp[i][Space] = max(dp[i - 1][Space], P[i - 1] + dp[i - 1][Space - W[i - 1]]); } } return dp[n][C];}int main(){ vector&lt;int&gt; W = {7, 2, 4}, P = {10, 5, 6}; int C = 7; cout &lt;&lt; knapsack(W, P, C, W.size() - 1); return 0;}Complexity Analysis Time complexity: $\\boldsymbol{O(n*C)}$ - We have 2 nested for loops that run in total of $\\boldsymbol{n*C}$ times. Space complexity: $\\boldsymbol{O(n*C)}$ - We are caching $\\boldsymbol{n*C}$ results in our 2D matrix/array." } ]
